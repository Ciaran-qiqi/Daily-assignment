# School三种学生管理合约结构对比与可迭代链表说明

## 一、三种实现方式结构对比

| 合约名                  | 核心结构         | 增删查复杂度 | 排序支持 | 适用场景           | 优点                   | 缺点                   |
|-------------------------|------------------|-------------|----------|--------------------|------------------------|------------------------|
| SchoolMapping           | mapping+数组     | O(1)/O(1)   | 无       | 快速查找/删除      | 查找/删除高效          | 无序，遍历需辅助数组   |
| SchoolBaseArray         | 纯数组           | O(n)/O(n)   | 无       | 小名单/简单场景    | 结构简单，易理解        | 查找/删除慢，易重复    |
| SchoolSortedLinkedList  | mapping+链表指针 | O(1)/O(1)   | 支持分数排序 | 排名、排行榜、动态排序 | 查找快，动态排序，遍历有序 | 结构复杂，gas略高      |

---

## 二、可迭代链表原理与结构

### 1. 数据结构
- 每个学生用一个结构体Student存储，包含：
  - 地址（addr）
  - 分数（score）
  - 前后指针（prev/next）
  - 是否存在（exists）
- 所有学生用mapping(address => Student)管理，O(1)查找。
- 通过head/tail指针维护链表头尾，实现有序遍历。

### 2. 插入/删除/排序机制
- **插入**：新学生按分数插入到链表合适位置，保证链表始终有序（分数从高到低）。
- **删除**：只需断开前后指针，O(1)完成。
- **分数变动**：
  - 提高分数时，自动向前移动，直到分数大于前一个节点。
  - 降低分数时，自动向后移动，直到分数小于后一个节点。
- **遍历**：从head开始，依次next即可获取有序名单。

### 3. 典型用法
- 排行榜、积分榜、动态排名、Top-K查询等需要频繁排序和查找的场景。
- 例如：游戏积分榜、NFT排行榜、链上竞赛排名等。

---

## 三、可迭代链表的优势与适用场景
- **优势**：
  - 查找、插入、删除均为O(1)复杂度。
  - 支持动态分数变动时的自动排序。
  - 遍历时天然有序，便于Top-K等需求。
- **适用场景**：
  - 需要频繁查找、动态排序、获取前N名的链上业务。
  - 比如链上排行榜、实时竞赛、积分管理等。

---

## 四、总结
- mapping适合高效查找、删除但无序的场景。
- 纯数组适合名单小、操作简单的场景。
- 可迭代链表适合需要有序、动态排序、Top-K等复杂业务。

理解三种结构的优缺点，有助于根据实际业务需求选择最优的链上数据结构。 

---

## 五、可迭代链表的分页查询

### 1. 原理
- 利用链表的next指针，从任意节点出发，依次遍历，按需分页。
- 不需要全量遍历或复制大数组，链上资源消耗低。

### 2. 典型接口
```solidity
/**
 * @dev 分页获取学生名单
 * @param start 起始学生地址（第一页用head，下一页用上次返回的nextStart）
 * @param pageSize 每页数量
 * @return studentsPage 当前页学生地址数组
 * @return nextStart 下一页起始地址（为address(0)表示已到末尾）
 */
function getStudentsPage(address start, uint256 pageSize) external view returns (address[] memory studentsPage, address nextStart);
```

### 3. 用法示例
- 获取第一页：`getStudentsPage(head, 10)`
- 获取第二页：`getStudentsPage(上次返回的nextStart, 10)`

### 4. 优势
- 支持链上大名单的分步拉取和前端分页展示。
- 不会因名单过大导致gas爆炸或超出返回限制。

--- 